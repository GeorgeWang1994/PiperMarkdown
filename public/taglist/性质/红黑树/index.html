
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>红黑树 - George1994</title>
    <meta name="author" content="George1994">
    <meta name="description" content=" George1994 is great man " />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"/>
    <link rel="shortcut icon" type="image/ico" href="/static/favicon.ico">

    <link href="/static/style2/style.css" rel="stylesheet" type="text/css" media="all">
    <link href="/static/style2/solarized.css" rel="stylesheet" type="text/css">
  </head>

  <body>
    
    
        <img class="bg-image" src="/static/background.jpg" />
    


    <header id="header" class="clearfix header-fixed-top base-header">
      <div class="nav">
        <h1><a href="/">George1994</a></h1>
<ul>
  <li><a href="/about_me/">About</a></li>
  <li><a href="/link/">Links</a></li>
  <li><a href="/archives/">Archives</a></li>
  <li><a href="/taglist/">Tags</a></li>
  <li><a href="/projects/">Projects</a></li>
</ul>

      </div>
    </header>

    <div id="container">
      <div class="content clearfix">
      
    <article>
        <h2>
            <a href="#">红黑树</a>
            <small class="date-right">2012-12-12 12:23:24</small>
        </h2>
        <div class="tag-list">Tags:
        
            <a href="/taglist/%E5%8F%B6%E5%AD%90">#叶子</a>
        
            <a href="/taglist/%E9%BB%91%E8%89%B2">#黑色</a>
        
            <a href="/taglist/%E6%80%A7%E8%B4%A8">#性质</a>
        
            <a href="/taglist/%E6%A0%B9">#根</a>
        
            <a href="/taglist/%E9%BB%91%E8%89%B2">#黑色</a>
        
            <a href="/taglist/%E6%80%A7%E8%B4%A8">#性质</a>
        
            <a href="/taglist/%E6%A0%B9">#根</a>
        
        </div>
        <div>
        <h1>红黑树</h1>
<h2>性质</h2>
<ol>
<li>红黑树的结点都是红色或者黑色</li>
<li>根结点是黑色</li>
<li>所有叶子都是黑色（这里的叶子结点是空结点）</li>
<li>每个红色结点必须有两个黑色的子结点</li>
<li>从任何一个节点到其每个叶子的所有简单路径都包含相同数目的黑色结点</li>
</ol>
<hr>
<ul>
<li>性质1和性质3总是能够保持着；</li>
<li>性质4只有在这些情况下才会发生作用：<ul>
<li>增加红色结点</li>
<li>将黑色结点重新绘制成红色结点</li>
<li>旋转</li>
</ul>
</li>
<li>性质5在这些情况下才会发生作用：<ul>
<li>增加黑色结点</li>
<li>将红色结点重新绘制黑色结点</li>
<li>旋转</li>
</ul>
</li>
</ul>
<p>举例：</p>
<figure><img src="http://odwv9d2u8.bkt.clouddn.com/17-5-21/336288-file_1495348485855_15f08.png" alt="" /></figure>
<h2>插入</h2>
<p>用BST的方法将结点插入，将该结点标记为红色的（因为如果标记为黑色，则会导致根结点到叶子结点的路径会多出一个黑结点，无法满足性质5，而且不容易进行调整），插入的情况包括下面几种：</p>
<ol>
<li>插入到一个空的树，插入结点则为根结点，只需要将红色结点重新转染成黑色结点来满足性质2；</li>
<li>新结点的父结点为黑色，满足所有条件；</li>
<li><p>新结点的父结点为红色，因为性质2和性质4，所以树必然有祖父结点，则又包括以下的情况：</p>
<ol>
<li><p>父亲结点和叔父结点均为红色，显然无法满足性质4，则将父亲结点和叔父结点绘制成黑色，祖父结点设置成红色，但是仍然无法满足情况，比如考虑到祖父结点可能是根结点，则无法满足性质2，或者祖父结点的父结点是红色的，则无法满足性质4，这时需要将祖父结点作为新的结点来看待进行各种情况的判断，涉及到对祖父结点的递归；</p>
<p> <img src="http://odwv9d2u8.bkt.clouddn.com/17-5-25/76425555.jpg" alt="" /></p>
</li>
<li><p>父亲结点为红色同时叔父结点为黑色或者从缺，这里又分为两种情况，新插入结点为父亲结点的左子结点和右子结点（假设其中父亲结点为祖父结点的左子结点），区别在于旋转的方向，显然，这棵树父亲结点既然为红色，那么其祖父结点则为黑色（性质4），不然无法满足前提。</p>
<ol>
<li><p>新插入结点为父亲结点的左子结点，那么就构成了一个左左的情况，在之前平衡树中提到过，如果要将其进行平衡，则需要对父结点进行一次单右旋转，形成一个父亲结点为相对根结点，子结点和祖父结点为子结点的树，同时将父亲结点的红色改为黑色，祖父结点更改为红色，这下之前无法满足的性质4和性质5就满足了；</p>
<p> <img src="http://odwv9d2u8.bkt.clouddn.com/17-5-25/82545074.jpg" alt="" /></p>
</li>
<li><p>新插入结点为父亲结点的右子结点，那么就会构成一个左右的情况，在之前的平衡树也提到过要进行一次双旋转，先对新结点进行一次单左旋转，变成了左左的结构，再进行一次单右旋转，从而达到满足所有性质；</p>
<p> <img src="http://odwv9d2u8.bkt.clouddn.com/17-5-25/9302564.jpg" alt="" /></p>
</li>
</ol>
</li>
<li><p>父亲结点是祖父结点的右结点，参考平衡树进行相应的操作，原理是一致的</p>
</li>
</ol>
</li>
</ol>
<h3>实现</h3>
<p>自然先看头文件，如下：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="n">RB_RED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">RB_BLACK</span>
<span class="p">}</span> <span class="n">RBColor</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="p">{</span>
    <span class="n">RBColor</span> <span class="n">rb_color</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">rb_key</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">rb_left</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">rb_right</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">rb_parent</span><span class="p">;</span>

    <span class="n">RBTreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="o">:</span> <span class="n">rb_key</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">rb_color</span><span class="p">(</span><span class="n">RB_BLACK</span><span class="p">),</span> <span class="n">rb_left</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">rb_right</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">rb_parent</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">RBTreeRoot</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">rb_node</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">RBTree</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">RBTree</span><span class="p">();</span>
    <span class="o">~</span><span class="n">RBTree</span><span class="p">();</span>

    <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">print</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">_left_rotate</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeRoot</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">node</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">_right_rotate</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeRoot</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">node</span><span class="p">);</span>
    <span class="n">RBTreeNode</span><span class="o">*</span> <span class="nf">insert_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">node</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">_insert_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">node</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">_print</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">);</span>

    <span class="k">struct</span> <span class="n">RBTreeRoot</span><span class="o">*</span> <span class="n">_root</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div><p>当然，为了使用更方便，还定义了一些红定义和内联函数；</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#define rb_parent(r)    ((struct RBTreeNode *)((r)-&gt;rb_parent))</span>
<span class="cp">#define rb_color(r)     ((r)-&gt;rb_color)</span>
<span class="cp">#define rb_is_red(r)    ((r)-&gt;rb_color &amp; RB_RED)</span>
<span class="cp">#define rb_is_black(r)  ((r)-&gt;rb_color &amp; RB_BLACK)</span>
<span class="cp">#define rb_set_red(r)   ((r)-&gt;rb_color = RB_RED)</span>
<span class="cp">#define rb_set_black(r) ((r)-&gt;rb_color = RB_BLACK)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rb_set_reds</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
    <span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
    <span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rb_set_red</span><span class="p">(</span><span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rb_set_blacks</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
    <span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
    <span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rb_set_black</span><span class="p">(</span><span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rb_set_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">cb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cb</span><span class="o">-&gt;</span><span class="n">rb_parent</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rb_set_left</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">cb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cb</span><span class="o">-&gt;</span><span class="n">rb_left</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">rb_set_parent</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rb_set_right</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">cb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cb</span><span class="o">-&gt;</span><span class="n">rb_right</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">rb_set_parent</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">rb_is_left</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">cb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_left</span> <span class="o">==</span> <span class="n">cb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">rb_is_right</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">cb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_right</span> <span class="o">==</span> <span class="n">cb</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div><p>真正的实现在这里，其操作可以参考平衡二叉树：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">RBTree</span><span class="o">::</span><span class="n">RBTree</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">_root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RBTreeRoot</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">RBTree</span><span class="o">::~</span><span class="n">RBTree</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="n">_root</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 对红黑树的节点(x)进行左旋转</span>
<span class="cm"> *</span>
<span class="cm"> * 左旋示意图(对节点x进行左旋)：</span>
<span class="cm"> *      px                              px</span>
<span class="cm"> *     /                               /</span>
<span class="cm"> *    x                               y</span>
<span class="cm"> *   /  \      --(左旋)--&gt;           / \         #</span>
<span class="cm"> *  lx   y                          x  ry</span>
<span class="cm"> *     /   \                       /  \</span>
<span class="cm"> *    ly   ry                     lx  ly</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">RBTree</span><span class="o">::</span><span class="n">_left_rotate</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeRoot</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">right</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">rb_parent</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

    <span class="c1">// 第一步：将ly连接到x的右结点上</span>
    <span class="n">rb_set_right</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">);</span>

    <span class="c1">// 第二步：将x设置为y的左子结点</span>
    <span class="n">rb_set_left</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

    <span class="c1">// 第三步：将y设置为px的子结点</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rb_is_left</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">rb_set_left</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">rb_set_right</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span> <span class="c1">// 根结点</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 对红黑树的节点(y)进行右旋转</span>
<span class="cm"> *</span>
<span class="cm"> * 右旋示意图(对节点y进行左旋)：</span>
<span class="cm"> *            py                               py</span>
<span class="cm"> *           /                                /</span>
<span class="cm"> *          y                                x</span>
<span class="cm"> *         /  \      --(右旋)--&gt;            /  \                     #</span>
<span class="cm"> *        x   ry                           lx   y</span>
<span class="cm"> *       / \                                   / \                   #</span>
<span class="cm"> *      lx  rx                                rx  ry</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">RBTree</span><span class="o">::</span><span class="n">_right_rotate</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeRoot</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">left</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">rb_parent</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

    <span class="c1">// 第一步：将rx设置为y的左子结点</span>
    <span class="n">rb_set_left</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">left</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">);</span>

    <span class="c1">// 第二步：将y设置为x的右子结点</span>
    <span class="n">rb_set_right</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

    <span class="c1">// 第三步：将x设置为py的子结点</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rb_is_left</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">rb_set_left</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">rb_set_right</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">RBTree</span><span class="o">::</span><span class="n">_insert_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="o">*</span><span class="n">g_parent</span><span class="p">;</span>

    <span class="c1">// 满足性质4</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">parent</span> <span class="o">=</span> <span class="n">rb_parent</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">rb_is_red</span><span class="p">(</span><span class="n">parent</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">g_parent</span> <span class="o">=</span> <span class="n">rb_parent</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>

        <span class="c1">// ?? 怎么知道祖父结点不为空</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">rb_is_left</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">g_parent</span><span class="p">))</span> <span class="p">{</span>
            <span class="p">{</span>
                <span class="c1">// case 1：叔叔结点是红色</span>
                <span class="c1">// 寄存器变量，提高效率</span>
                <span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">uncle</span> <span class="o">=</span> <span class="n">g_parent</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
                <span class="c1">// 无法满足性质4</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">uncle</span> <span class="o">&amp;&amp;</span> <span class="n">rb_is_red</span><span class="p">(</span><span class="n">uncle</span><span class="p">))</span> <span class="p">{</span>
                    <span class="c1">// step1：将父亲和叔叔结点设置成黑色</span>
                    <span class="n">rb_set_blacks</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">uncle</span><span class="p">);</span>
                    <span class="c1">// step2：将祖父设置成红色（因为之前必然为黑色，不然无法满足性质4）</span>
                    <span class="n">rb_set_red</span><span class="p">(</span><span class="n">g_parent</span><span class="p">);</span>
                    <span class="c1">// step3：递归检查祖父结点</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">g_parent</span><span class="p">;</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="c1">// 无法满足性质5</span>
            <span class="c1">// case 2：叔叔结点是黑色，并且当前结点在右边，必然要进行双旋转</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">rb_is_right</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>

                <span class="c1">// step 1：将父亲结点进行左旋</span>
                <span class="n">_left_rotate</span><span class="p">(</span><span class="n">_root</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span> <span class="c1">// 此时父结点为当前结点的左子结点</span>
                <span class="c1">// step 2：将当前结点和父结点进行交换</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// 此时父亲结点和当前结点均是红色，无法满足性质4和性质5</span>
            <span class="c1">// case 3：叔叔结点是黑色，并且当前结点在左边，只用单旋转</span>
            <span class="c1">// step 1：将父亲结点改成改成黑色，祖父结点改成红色，以便后面进行旋转后，</span>
            <span class="c1">// 红色的左子结点和祖父结点为黑色的父结点的子结点</span>
            <span class="n">rb_set_black</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
            <span class="n">rb_set_red</span><span class="p">(</span><span class="n">g_parent</span><span class="p">);</span>
            <span class="c1">// step 2：右旋转</span>
            <span class="n">_right_rotate</span><span class="p">(</span><span class="n">_root</span><span class="p">,</span> <span class="n">g_parent</span><span class="p">);</span>  <span class="c1">// 经过右旋转后，红色均分布在两边</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>  <span class="c1">// 顺序相反而已</span>
            <span class="p">{</span>
                <span class="c1">// case 4：叔叔结点是红色</span>
                <span class="c1">// 寄存器变量，提高效率</span>
                <span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">uncle</span> <span class="o">=</span> <span class="n">g_parent</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
                <span class="c1">// 无法满足性质4</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">uncle</span> <span class="o">&amp;&amp;</span> <span class="n">rb_is_red</span><span class="p">(</span><span class="n">uncle</span><span class="p">))</span> <span class="p">{</span>
                    <span class="c1">// step1：将父亲和叔叔结点设置成黑色</span>
                    <span class="n">rb_set_blacks</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">uncle</span><span class="p">);</span>
                    <span class="c1">// step2：将祖父设置成红色（因为之前必然为黑色，不然无法满足性质4）</span>
                    <span class="n">rb_set_red</span><span class="p">(</span><span class="n">g_parent</span><span class="p">);</span>
                    <span class="c1">// step3：递归检查祖父结点</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">g_parent</span><span class="p">;</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="c1">// 无法满足性质5</span>
            <span class="c1">// case 5：叔叔结点是黑色，并且当前结点在左边，必然要进行双旋转</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">rb_is_left</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>

                <span class="c1">// step 1：将父亲结点进行左旋</span>
                <span class="n">_right_rotate</span><span class="p">(</span><span class="n">_root</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span> <span class="c1">// 此时父结点为当前结点的右子结点</span>
                <span class="c1">// step 2：将当前结点和父结点进行交换</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// 此时父亲结点和当前结点均是红色，无法满足性质4和性质5</span>
            <span class="c1">// case 3：叔叔结点是黑色，并且当前结点在右边，只用单旋转</span>
            <span class="c1">// step 1：将父亲结点改成改成黑色，祖父结点改成红色，以便后面进行旋转后，</span>
            <span class="c1">// 红色的左子结点和祖父结点为黑色的父结点的子结点</span>
            <span class="n">rb_set_black</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
            <span class="n">rb_set_red</span><span class="p">(</span><span class="n">g_parent</span><span class="p">);</span>
            <span class="c1">// step 2：左旋转</span>
            <span class="n">_left_rotate</span><span class="p">(</span><span class="n">_root</span><span class="p">,</span> <span class="n">g_parent</span><span class="p">);</span>  <span class="c1">// 经过左旋转后，红色均分布在两边</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 参照BST的插入方法</span>
<span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">RBTree</span><span class="o">::</span><span class="n">insert_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">_root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">temp_parent</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">temp</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temp_parent</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_key</span> <span class="o">&lt;</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">rb_key</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 设置子结点</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">temp_parent</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_key</span> <span class="o">&lt;</span> <span class="n">temp_parent</span><span class="o">-&gt;</span><span class="n">rb_key</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">rb_set_left</span><span class="p">(</span><span class="n">temp_parent</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">rb_set_right</span><span class="p">(</span><span class="n">temp_parent</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">_root</span><span class="o">-&gt;</span><span class="n">rb_node</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>  <span class="c1">// 根结点</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">RBTree</span><span class="o">::</span><span class="n">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RBTreeNode</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="n">node</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">insert_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">_insert_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">RBTree</span><span class="o">::</span><span class="n">_print</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_print</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_key</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;   &quot;</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_print</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">RBTree</span><span class="o">::</span><span class="n">print</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">_print</span><span class="p">(</span><span class="n">_root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div><h2>删除</h2>
<p>因为根据BST中的规则，选择该结点的左子树中最大值和右子树中最小值替代掉原本要删除的点的值，再将改点删掉即可，所以这里只会讨论那个删掉的点。</p>
<p>分为以下情况：</p>
<ol>
<li>删除结点的左右子结点均为空，则将其直接删除即可；</li>
<li>删除结点的左右子结点不为空，则情况又分为好几种，删除结点为红色，子结点必然为黑色，用子结点进行替代即可；还有删除结点为黑色，而子结点为红色，则重新绘制子结点为黑色替代删除结点即可；还有删除结点为黑色，其子结点也为黑色，首先将子结点替换掉删除结点，这个则分为好几种情况：<ol>
<li>子结点为新的根，此时只是将所有的路径中都去除一个黑色结点，所以依然保持平衡；</li>
<li>子结点的兄弟结点为红色，</li>
</ol>
</li>
</ol>
<p>假设N为要删除的点，P为N的父亲结点，S为N的兄弟结点，还有S左子结点为Sl和右子结点Sr，其中N为P的左子结点，S为右子结点；</p>
<p>大体上分好几种情况，P可能为红色或者黑色（两种），S可能为红色可能为黑色，Sl和Sr也可能为红色或者黑色，所以具体则分为以下几种：</p>
<ol>
<li>P为黑色<ol>
<li>N为红色（其子结点必为黑色），S为黑色；</li>
<li>N为黑色，S为红色（其子结点必为黑色）；</li>
</ol>
</li>
<li>P为红色，则其S和N均为黑色<ol>
<li>Sl为红色，Sr为黑色；</li>
<li>Sl为黑色，Sr为红色；</li>
<li>Sl和Sr均为黑色；</li>
</ol>
</li>
</ol>
<p>先看1.a，用随便一个N的黑色子结点替代即可，没有造成失衡，符合所有性质；</p>
<p>再看1.b，此时对P进行一个左旋转，旋转后如下图，变成了以S为相对根结点，P为红色左子结点的树；
<img src="http://odwv9d2u8.bkt.clouddn.com/17-5-21/4624011-file_1495361356381_31f6.png" alt="" /></p>
<p>再看2.a，要对S进行一个右旋转，此时就变成了2.c的情况，如下图：
<img src="http://odwv9d2u8.bkt.clouddn.com/17-5-21/28372718-file_1495362072281_17fe7.png" alt="" /></p>
<p>再看2.b，对P进行一个左旋转，如下图，需要注意的是，在示意图中的白色节点可以是红色或黑色，但是在变换前后都必须指定相同的颜色；
<img src="http://odwv9d2u8.bkt.clouddn.com/17-5-21/88599288-file_1495362167693_163dc.png" alt="" /></p>
<p>再看2.c，将S简单的进行重绘即可，但是导致了经过S的黑色结点的数量减少了一个，所以则需要通过递归处理；
<img src="http://odwv9d2u8.bkt.clouddn.com/17-5-21/83493056-file_1495364122278_7ac4.png" alt="" /></p>
<h2>区别</h2>
<p>和平衡二叉树的区别在于（stack overflow）：</p>
<blockquote><p>AVL trees maintain a more rigid balance than red-black trees. The path from the root to the deepest leaf in an AVL tree is at most ~1.44 lg(n+2), while in red black trees it's at most ~2 lg (n+1).
As a result, lookup in an AVL tree is typically faster, but this comes at the cost of slower insertion and deletion due to more rotation operations. So use an AVL tree if you expect the number of lookups to dominate the number of updates to the tree.</p>
</blockquote>
<hr>
<blockquote><p>For small data:
insert: RB tree &amp; avl tree has constant number of max rotation but RB tree will be faster because on average RB tree use less rotation.
lookup: AVL tree is faster, because AVL tree has less depth.
delete: RB tree has constant number of max rotation but AVL tree can have O(log N) times of rotation as worst. and on average RB tree also has less number of rotation thus RB tree is faster.
for large data:
insert: AVL tree is faster. because you need to lookup for a particular node before insertion. as you have more data the time difference on looking up the particular node grows proportional to O(log N). but AVL tree &amp; RB tree still only need constant number of rotation at the worst case. Thus the bottle neck will become the time you lookup for that particular node.
lookup: AVL tree is faster. (same as in small data case)
delete: AVL tree is faster on average, but in worst case RB tree is faster. because you also need to lookup for a very deep node to swap before removal (similar to the reason of insertion). on average both trees has constant number of rotation. but RB tree has a constant upper bound for rotation.</p>
</blockquote>

        </div>
    </article>
    <blockquote>
        <small>

        </small>
    </blockquote>

      </div>
      <footer id="footer" class="top-box clearfix">
        &copy; 2016-2019  | <a href="/" title="By George1994">George1994's Blog</a> with
        <a href="/"> Piper </a>.
        <a href="javascript:scroll(0,0)" class="to-top">TOP</a>
      </footer>
      
      
    </div>
  </body>
</html>
