
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>George1994</title>
    <meta name="author" content="George1994">
    <meta name="description" content=" George1994 is great " />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"/>
    <link rel="shortcut icon" type="image/ico" href="/static/favicon.ico">

    <link href="/static/style2/style.css" rel="stylesheet" type="text/css" media="all">
    <link href="/static/style2/solarized.css" rel="stylesheet" type="text/css">
  </head>

  <body>
    
    <img class="bg-image" src="/static/background.jpg" />
    

    <header id="header" class="clearfix header-fixed-top">
      <div class="nav">
       <h1><a href="/">George1994</a></h1>
<ul>
  <li><a href="/about_me/">About</a></li>
  <li><a href="/link/">Links</a></li>
  <li><a href="/archives/">Archives</a></li>
  <li><a href="/taglist/">Tags</a></li>
  <li><a href="/projects/">Projects</a></li>
</ul>

      </div>
    </header>

    <div id="home-container">
        <div id="container" style="float: left;margin-top:25px">
          <div class="content clearfix">
          
            
                <h2>
                    <a href="/posts/Redis%E6%80%BB%E7%BB%93">Redis总结</a>
                    <small class="date-right">2017-06-05 17:05:14</small>
                </h2>
                <article>
                <p>your post</p>

                </article>
                <hr>
            
                <h2>
                    <a href="/posts/%E6%88%91%E7%9A%84%E4%B9%B1%E5%BC%B9%E2%80%94%E2%80%94%E4%BB%8E%E8%AF%BA%E8%B4%9D%E5%B0%94%E5%A5%96%E8%B0%88%E4%B8%AD%E5%9B%BD%E6%95%99%E8%82%B2">我的乱弹——从诺贝尔奖谈中国教育</a>
                    <small class="date-right">2012-12-12 12:23:24</small>
                </h2>
                <article>
                <h1>我的乱弹——从诺贝尔奖谈中国教育</h1>
<p>本人并非教育砖家,也不是什么大学叫兽,所说之言,所述之理,也没什么权威性可言,但作为一个中学生的我,说的话的真实性肯定不会打折。对于在当今中国如此复杂又如此纠结的问题,我肯定是无法读懂的,但这里我可以谈谈自己的亲身经历和感受,来描述诺贝尔奖与中国教育的关系。</p>
<figure><img src="//dn-serho.qbox.me/blog/2009101101.jpg" alt="这其中你认得到多少个？" /></figure>
<p>说中国人没有得到过诺贝尔奖是不对的,当年合成结晶牛胰岛素,因人数问题与诺贝尔奖失之交臂,但是令国人稍感自豪的是,诺奖得主中确有几个中国人,这些人肯定家喻户晓,这里不多说。比如今年的高锟,这又让提高了一下国人的民族自豪感,从这些得诺奖的中国人可以看出：中国人是不笨的。但问题就出来了,为什么,那些获奖的国人都是华裔的,当然就是所谓的一个专有名词：某某籍华裔人士。这本来就是一种讽刺,一种黑色幽默。正如一位博主所言：我不知道和国际接轨的说法，是不是需要把每个获奖科学家的种族都要公布一下，但是国内通行的说法，是喜欢研究DNA的，你比如说我们很喜欢说获奖科学家是“美籍华人某某某”，或者“美籍华裔某某某”，这一次是“英国华裔”。</p>
<p>我听大部分网友议论过,或准确说是调侃过：这个高锟说得来中文不还得打个问号。但中国人确实很这样，说自己聪明，也是上面那位博主所说：“很多人说披萨是中国馅饼做的；足球是中国发明的；华裔获得诺贝尔奖项是为我们争光。但其实这都是YY，在YY中，我们获得无限的满足；在YY中，我想起了中国男足——看着皇马、巴萨、国际米兰、AC米兰、尤文图斯、葡萄牙、西班牙、德国、英国、荷兰，然后我们假装那是自己的球队。”这无疑引出了本文观点：中国,你的教育制度到底出什么问题了?</p>
<h3>这里我提出自己的几个观点</h3>
<p>一：素质教育还只是一种理念。或更狠一点说,根本就没有树立真正的素质教育理念。</p>
<p>记得很早就在谈素质教育了,并还流行了一把,各个省市就象追逐潮流一样追赶它,但是什么是真正的素质教育,追它的人自己也说不清。记得看过一个关于中美教育差别的文章,里面谈到：美国是一个没有标准答案的国家,你只需发动自己的思想,得出自己的答案即可,而中国却是,必需照参考答案行事,答案只有三条,你答三条半也算错。比如做语文的阅读题,明明问题是就文章什么什么发表你的看法,阅卷却是按答案来的,你和答案不一样,无论你谈的如何的有理,你还是错了。所以中国学生的思想被极度固化,没有灵活性。再者是应试教育这把匕首,不知摧残了多少人,不可否认,高考是现今这个不公平的社会里难得有点公平的事,也让不少农村孩子走出农村,但经历了三十年的高考,在中国人心中烙下了应试的印记。于是乎,学习什么都是为了高考而去,于是乎便成了做题的机器,对于高考不考的如社会实践,动手实验等就一概不适。总之这种禁固思想,缺乏实践能力的人,想冲击诺贝尔,那是相当的难。</p>
<p>二：关于文理分科,这点我将其单读作为一点,是有深意的。</p>
<p>我想大抵人才,都应该是学识比较丰富的,总能将人文与科学兼得,这从那些诺奖或得者可以看出。而中国现在的文理分科,其实就大大的削弱了学生这一能力。但我也并非主张文理不分科,因为读过高中的人都知道,那是相当的累,还有就是不改革高考,永远就不要讨论文理合科的事,因为上面所说的“应试”。</p>
<p>三：真正的思想教育。</p>
<p>中国的思想教育,不能称之为思想教育,准确说应该是政治教育。这里不多涉及,以免出格,总之,培养出了很多粪青,这到各大门户看看留言就知道了,关于这点,以后还有介绍。还有就是观念问题，高考的功利性，和现实的残酷性，我想，你随便到一个高中去问一个问题：当官还是搞科研，你选择什么？我想大部分是选择当官。如果这个问题到小学去问，我想很多人都会选择当科学家。这就说明，学生的变化是社会的影响造成的。</p>
<p>总之,不能获得诺贝尔奖,这不是个智力问题,而是个后天教育问题或叫体制问题，有人就说：诺贝尔奖是个资本主义性质的奖项,是不适合中国的,它在中国从来不代表世界最先进的科技,如果中国获得这样的奖,只是一种耻辱。我猜,这位仁兄肯定是被中国教育制度毒害很深的人,能说出这番话,从中可看出中国现有教育的一斑。诺奖的伟大与公正,我不想多说,你看一下,那个获得该奖的科技成果不是造福于人类。都说中国在崛起,我想,光经济上崛起是不长久的,还得文化,科技多方面的崛起,这就需要我们反思。我就谈这些,只是我的经历与感受,没什么可图的,图的就是给人们一点启示。</p>
<p>再补充一句：中国盲目的愤青不是一般的多啊！用别人的一句话结尾：如果有人问你，当官实在，还是搞科研实在？如果有一天你脱口而出是从事科技工作，那估计离国人真正拥有个姓诺的爷爷的日子就不远了。</p>

                </article>
                <hr>
            
                <h2>
                    <a href="/posts/%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>
                    <small class="date-right">2012-12-12 12:23:24</small>
                </h2>
                <article>
                <h1>红黑树</h1>
<h2>性质</h2>
<ol>
<li>红黑树的结点都是红色或者黑色</li>
<li>根结点是黑色</li>
<li>所有叶子都是黑色（这里的叶子结点是空结点）</li>
<li>每个红色结点必须有两个黑色的子结点</li>
<li>从任何一个节点到其每个叶子的所有简单路径都包含相同数目的黑色结点</li>
</ol>
<hr>
<ul>
<li>性质1和性质3总是能够保持着；</li>
<li>性质4只有在这些情况下才会发生作用：<ul>
<li>增加红色结点</li>
<li>将黑色结点重新绘制成红色结点</li>
<li>旋转</li>
</ul>
</li>
<li>性质5在这些情况下才会发生作用：<ul>
<li>增加黑色结点</li>
<li>将红色结点重新绘制黑色结点</li>
<li>旋转</li>
</ul>
</li>
</ul>
<p>举例：</p>
<figure><img src="http://odwv9d2u8.bkt.clouddn.com/17-5-21/336288-file_1495348485855_15f08.png" alt="" /></figure>
<h2>插入</h2>
<p>用BST的方法将结点插入，将该结点标记为红色的（因为如果标记为黑色，则会导致根结点到叶子结点的路径会多出一个黑结点，无法满足性质5，而且不容易进行调整），插入的情况包括下面几种：</p>
<ol>
<li>插入到一个空的树，插入结点则为根结点，只需要将红色结点重新转染成黑色结点来满足性质2；</li>
<li>新结点的父结点为黑色，满足所有条件；</li>
<li><p>新结点的父结点为红色，因为性质2和性质4，所以树必然有祖父结点，则又包括以下的情况：</p>
<ol>
<li><p>父亲结点和叔父结点均为红色，显然无法满足性质4，则将父亲结点和叔父结点绘制成黑色，祖父结点设置成红色，但是仍然无法满足情况，比如考虑到祖父结点可能是根结点，则无法满足性质2，或者祖父结点的父结点是红色的，则无法满足性质4，这时需要将祖父结点作为新的结点来看待进行各种情况的判断，涉及到对祖父结点的递归；</p>
<p> <img src="http://odwv9d2u8.bkt.clouddn.com/17-5-25/76425555.jpg" alt="" /></p>
</li>
<li><p>父亲结点为红色同时叔父结点为黑色或者从缺，这里又分为两种情况，新插入结点为父亲结点的左子结点和右子结点（假设其中父亲结点为祖父结点的左子结点），区别在于旋转的方向，显然，这棵树父亲结点既然为红色，那么其祖父结点则为黑色（性质4），不然无法满足前提。</p>
<ol>
<li><p>新插入结点为父亲结点的左子结点，那么就构成了一个左左的情况，在之前平衡树中提到过，如果要将其进行平衡，则需要对父结点进行一次单右旋转，形成一个父亲结点为相对根结点，子结点和祖父结点为子结点的树，同时将父亲结点的红色改为黑色，祖父结点更改为红色，这下之前无法满足的性质4和性质5就满足了；</p>
<p> <img src="http://odwv9d2u8.bkt.clouddn.com/17-5-25/82545074.jpg" alt="" /></p>
</li>
<li><p>新插入结点为父亲结点的右子结点，那么就会构成一个左右的情况，在之前的平衡树也提到过要进行一次双旋转，先对新结点进行一次单左旋转，变成了左左的结构，再进行一次单右旋转，从而达到满足所有性质；</p>
<p> <img src="http://odwv9d2u8.bkt.clouddn.com/17-5-25/9302564.jpg" alt="" /></p>
</li>
</ol>
</li>
<li><p>父亲结点是祖父结点的右结点，参考平衡树进行相应的操作，原理是一致的</p>
</li>
</ol>
</li>
</ol>
<h3>实现</h3>
<p>自然先看头文件，如下：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="n">RB_RED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">RB_BLACK</span>
<span class="p">}</span> <span class="n">RBColor</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="p">{</span>
    <span class="n">RBColor</span> <span class="n">rb_color</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">rb_key</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">rb_left</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">rb_right</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">rb_parent</span><span class="p">;</span>

    <span class="n">RBTreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="o">:</span> <span class="n">rb_key</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">rb_color</span><span class="p">(</span><span class="n">RB_BLACK</span><span class="p">),</span> <span class="n">rb_left</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">rb_right</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">rb_parent</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">RBTreeRoot</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">rb_node</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">RBTree</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">RBTree</span><span class="p">();</span>
    <span class="o">~</span><span class="n">RBTree</span><span class="p">();</span>

    <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">print</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">_left_rotate</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeRoot</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">node</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">_right_rotate</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeRoot</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">node</span><span class="p">);</span>
    <span class="n">RBTreeNode</span><span class="o">*</span> <span class="nf">insert_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">node</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">_insert_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">node</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">_print</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">);</span>

    <span class="k">struct</span> <span class="n">RBTreeRoot</span><span class="o">*</span> <span class="n">_root</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div><p>当然，为了使用更方便，还定义了一些红定义和内联函数；</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#define rb_parent(r)    ((struct RBTreeNode *)((r)-&gt;rb_parent))</span>
<span class="cp">#define rb_color(r)     ((r)-&gt;rb_color)</span>
<span class="cp">#define rb_is_red(r)    ((r)-&gt;rb_color &amp; RB_RED)</span>
<span class="cp">#define rb_is_black(r)  ((r)-&gt;rb_color &amp; RB_BLACK)</span>
<span class="cp">#define rb_set_red(r)   ((r)-&gt;rb_color = RB_RED)</span>
<span class="cp">#define rb_set_black(r) ((r)-&gt;rb_color = RB_BLACK)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rb_set_reds</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
    <span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
    <span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rb_set_red</span><span class="p">(</span><span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rb_set_blacks</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
    <span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
    <span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rb_set_black</span><span class="p">(</span><span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rb_set_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">cb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cb</span><span class="o">-&gt;</span><span class="n">rb_parent</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rb_set_left</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">cb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cb</span><span class="o">-&gt;</span><span class="n">rb_left</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">rb_set_parent</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rb_set_right</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">cb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cb</span><span class="o">-&gt;</span><span class="n">rb_right</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">rb_set_parent</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">rb_is_left</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">cb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_left</span> <span class="o">==</span> <span class="n">cb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">rb_is_right</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">cb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_right</span> <span class="o">==</span> <span class="n">cb</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div><p>真正的实现在这里，其操作可以参考平衡二叉树：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">RBTree</span><span class="o">::</span><span class="n">RBTree</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">_root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RBTreeRoot</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">RBTree</span><span class="o">::~</span><span class="n">RBTree</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="n">_root</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 对红黑树的节点(x)进行左旋转</span>
<span class="cm"> *</span>
<span class="cm"> * 左旋示意图(对节点x进行左旋)：</span>
<span class="cm"> *      px                              px</span>
<span class="cm"> *     /                               /</span>
<span class="cm"> *    x                               y</span>
<span class="cm"> *   /  \      --(左旋)--&gt;           / \         #</span>
<span class="cm"> *  lx   y                          x  ry</span>
<span class="cm"> *     /   \                       /  \</span>
<span class="cm"> *    ly   ry                     lx  ly</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">RBTree</span><span class="o">::</span><span class="n">_left_rotate</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeRoot</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">right</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">rb_parent</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

    <span class="c1">// 第一步：将ly连接到x的右结点上</span>
    <span class="n">rb_set_right</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">);</span>

    <span class="c1">// 第二步：将x设置为y的左子结点</span>
    <span class="n">rb_set_left</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

    <span class="c1">// 第三步：将y设置为px的子结点</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rb_is_left</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">rb_set_left</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">rb_set_right</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span> <span class="c1">// 根结点</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 对红黑树的节点(y)进行右旋转</span>
<span class="cm"> *</span>
<span class="cm"> * 右旋示意图(对节点y进行左旋)：</span>
<span class="cm"> *            py                               py</span>
<span class="cm"> *           /                                /</span>
<span class="cm"> *          y                                x</span>
<span class="cm"> *         /  \      --(右旋)--&gt;            /  \                     #</span>
<span class="cm"> *        x   ry                           lx   y</span>
<span class="cm"> *       / \                                   / \                   #</span>
<span class="cm"> *      lx  rx                                rx  ry</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">RBTree</span><span class="o">::</span><span class="n">_right_rotate</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeRoot</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">left</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">rb_parent</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

    <span class="c1">// 第一步：将rx设置为y的左子结点</span>
    <span class="n">rb_set_left</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">left</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">);</span>

    <span class="c1">// 第二步：将y设置为x的右子结点</span>
    <span class="n">rb_set_right</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

    <span class="c1">// 第三步：将x设置为py的子结点</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rb_is_left</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">rb_set_left</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">rb_set_right</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">RBTree</span><span class="o">::</span><span class="n">_insert_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="o">*</span><span class="n">g_parent</span><span class="p">;</span>

    <span class="c1">// 满足性质4</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">parent</span> <span class="o">=</span> <span class="n">rb_parent</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">rb_is_red</span><span class="p">(</span><span class="n">parent</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">g_parent</span> <span class="o">=</span> <span class="n">rb_parent</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>

        <span class="c1">// ?? 怎么知道祖父结点不为空</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">rb_is_left</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">g_parent</span><span class="p">))</span> <span class="p">{</span>
            <span class="p">{</span>
                <span class="c1">// case 1：叔叔结点是红色</span>
                <span class="c1">// 寄存器变量，提高效率</span>
                <span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">uncle</span> <span class="o">=</span> <span class="n">g_parent</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
                <span class="c1">// 无法满足性质4</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">uncle</span> <span class="o">&amp;&amp;</span> <span class="n">rb_is_red</span><span class="p">(</span><span class="n">uncle</span><span class="p">))</span> <span class="p">{</span>
                    <span class="c1">// step1：将父亲和叔叔结点设置成黑色</span>
                    <span class="n">rb_set_blacks</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">uncle</span><span class="p">);</span>
                    <span class="c1">// step2：将祖父设置成红色（因为之前必然为黑色，不然无法满足性质4）</span>
                    <span class="n">rb_set_red</span><span class="p">(</span><span class="n">g_parent</span><span class="p">);</span>
                    <span class="c1">// step3：递归检查祖父结点</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">g_parent</span><span class="p">;</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="c1">// 无法满足性质5</span>
            <span class="c1">// case 2：叔叔结点是黑色，并且当前结点在右边，必然要进行双旋转</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">rb_is_right</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>

                <span class="c1">// step 1：将父亲结点进行左旋</span>
                <span class="n">_left_rotate</span><span class="p">(</span><span class="n">_root</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span> <span class="c1">// 此时父结点为当前结点的左子结点</span>
                <span class="c1">// step 2：将当前结点和父结点进行交换</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// 此时父亲结点和当前结点均是红色，无法满足性质4和性质5</span>
            <span class="c1">// case 3：叔叔结点是黑色，并且当前结点在左边，只用单旋转</span>
            <span class="c1">// step 1：将父亲结点改成改成黑色，祖父结点改成红色，以便后面进行旋转后，</span>
            <span class="c1">// 红色的左子结点和祖父结点为黑色的父结点的子结点</span>
            <span class="n">rb_set_black</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
            <span class="n">rb_set_red</span><span class="p">(</span><span class="n">g_parent</span><span class="p">);</span>
            <span class="c1">// step 2：右旋转</span>
            <span class="n">_right_rotate</span><span class="p">(</span><span class="n">_root</span><span class="p">,</span> <span class="n">g_parent</span><span class="p">);</span>  <span class="c1">// 经过右旋转后，红色均分布在两边</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>  <span class="c1">// 顺序相反而已</span>
            <span class="p">{</span>
                <span class="c1">// case 4：叔叔结点是红色</span>
                <span class="c1">// 寄存器变量，提高效率</span>
                <span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">uncle</span> <span class="o">=</span> <span class="n">g_parent</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
                <span class="c1">// 无法满足性质4</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">uncle</span> <span class="o">&amp;&amp;</span> <span class="n">rb_is_red</span><span class="p">(</span><span class="n">uncle</span><span class="p">))</span> <span class="p">{</span>
                    <span class="c1">// step1：将父亲和叔叔结点设置成黑色</span>
                    <span class="n">rb_set_blacks</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">uncle</span><span class="p">);</span>
                    <span class="c1">// step2：将祖父设置成红色（因为之前必然为黑色，不然无法满足性质4）</span>
                    <span class="n">rb_set_red</span><span class="p">(</span><span class="n">g_parent</span><span class="p">);</span>
                    <span class="c1">// step3：递归检查祖父结点</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">g_parent</span><span class="p">;</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="c1">// 无法满足性质5</span>
            <span class="c1">// case 5：叔叔结点是黑色，并且当前结点在左边，必然要进行双旋转</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">rb_is_left</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>

                <span class="c1">// step 1：将父亲结点进行左旋</span>
                <span class="n">_right_rotate</span><span class="p">(</span><span class="n">_root</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span> <span class="c1">// 此时父结点为当前结点的右子结点</span>
                <span class="c1">// step 2：将当前结点和父结点进行交换</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// 此时父亲结点和当前结点均是红色，无法满足性质4和性质5</span>
            <span class="c1">// case 3：叔叔结点是黑色，并且当前结点在右边，只用单旋转</span>
            <span class="c1">// step 1：将父亲结点改成改成黑色，祖父结点改成红色，以便后面进行旋转后，</span>
            <span class="c1">// 红色的左子结点和祖父结点为黑色的父结点的子结点</span>
            <span class="n">rb_set_black</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
            <span class="n">rb_set_red</span><span class="p">(</span><span class="n">g_parent</span><span class="p">);</span>
            <span class="c1">// step 2：左旋转</span>
            <span class="n">_left_rotate</span><span class="p">(</span><span class="n">_root</span><span class="p">,</span> <span class="n">g_parent</span><span class="p">);</span>  <span class="c1">// 经过左旋转后，红色均分布在两边</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 参照BST的插入方法</span>
<span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">RBTree</span><span class="o">::</span><span class="n">insert_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">_root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">temp_parent</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">temp</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temp_parent</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_key</span> <span class="o">&lt;</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">rb_key</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 设置子结点</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">temp_parent</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_key</span> <span class="o">&lt;</span> <span class="n">temp_parent</span><span class="o">-&gt;</span><span class="n">rb_key</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">rb_set_left</span><span class="p">(</span><span class="n">temp_parent</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">rb_set_right</span><span class="p">(</span><span class="n">temp_parent</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">_root</span><span class="o">-&gt;</span><span class="n">rb_node</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>  <span class="c1">// 根结点</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">RBTree</span><span class="o">::</span><span class="n">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RBTreeNode</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="n">node</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">insert_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">_insert_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">RBTree</span><span class="o">::</span><span class="n">_print</span><span class="p">(</span><span class="k">struct</span> <span class="n">RBTreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_print</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_key</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;   &quot;</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_print</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">RBTree</span><span class="o">::</span><span class="n">print</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">_print</span><span class="p">(</span><span class="n">_root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div><h2>删除</h2>
<p>因为根据BST中的规则，选择该结点的左子树中最大值和右子树中最小值替代掉原本要删除的点的值，再将改点删掉即可，所以这里只会讨论那个删掉的点。</p>
<p>分为以下情况：</p>
<ol>
<li>删除结点的左右子结点均为空，则将其直接删除即可；</li>
<li>删除结点的左右子结点不为空，则情况又分为好几种，删除结点为红色，子结点必然为黑色，用子结点进行替代即可；还有删除结点为黑色，而子结点为红色，则重新绘制子结点为黑色替代删除结点即可；还有删除结点为黑色，其子结点也为黑色，首先将子结点替换掉删除结点，这个则分为好几种情况：<ol>
<li>子结点为新的根，此时只是将所有的路径中都去除一个黑色结点，所以依然保持平衡；</li>
<li>子结点的兄弟结点为红色，</li>
</ol>
</li>
</ol>
<p>假设N为要删除的点，P为N的父亲结点，S为N的兄弟结点，还有S左子结点为Sl和右子结点Sr，其中N为P的左子结点，S为右子结点；</p>
<p>大体上分好几种情况，P可能为红色或者黑色（两种），S可能为红色可能为黑色，Sl和Sr也可能为红色或者黑色，所以具体则分为以下几种：</p>
<ol>
<li>P为黑色<ol>
<li>N为红色（其子结点必为黑色），S为黑色；</li>
<li>N为黑色，S为红色（其子结点必为黑色）；</li>
</ol>
</li>
<li>P为红色，则其S和N均为黑色<ol>
<li>Sl为红色，Sr为黑色；</li>
<li>Sl为黑色，Sr为红色；</li>
<li>Sl和Sr均为黑色；</li>
</ol>
</li>
</ol>
<p>先看1.a，用随便一个N的黑色子结点替代即可，没有造成失衡，符合所有性质；</p>
<p>再看1.b，此时对P进行一个左旋转，旋转后如下图，变成了以S为相对根结点，P为红色左子结点的树；
<img src="http://odwv9d2u8.bkt.clouddn.com/17-5-21/4624011-file_1495361356381_31f6.png" alt="" /></p>
<p>再看2.a，要对S进行一个右旋转，此时就变成了2.c的情况，如下图：
<img src="http://odwv9d2u8.bkt.clouddn.com/17-5-21/28372718-file_1495362072281_17fe7.png" alt="" /></p>
<p>再看2.b，对P进行一个左旋转，如下图，需要注意的是，在示意图中的白色节点可以是红色或黑色，但是在变换前后都必须指定相同的颜色；
<img src="http://odwv9d2u8.bkt.clouddn.com/17-5-21/88599288-file_1495362167693_163dc.png" alt="" /></p>
<p>再看2.c，将S简单的进行重绘即可，但是导致了经过S的黑色结点的数量减少了一个，所以则需要通过递归处理；
<img src="http://odwv9d2u8.bkt.clouddn.com/17-5-21/83493056-file_1495364122278_7ac4.png" alt="" /></p>
<h2>区别</h2>
<p>和平衡二叉树的区别在于（stack overflow）：</p>
<blockquote><p>AVL trees maintain a more rigid balance than red-black trees. The path from the root to the deepest leaf in an AVL tree is at most ~1.44 lg(n+2), while in red black trees it's at most ~2 lg (n+1).
As a result, lookup in an AVL tree is typically faster, but this comes at the cost of slower insertion and deletion due to more rotation operations. So use an AVL tree if you expect the number of lookups to dominate the number of updates to the tree.</p>
</blockquote>
<hr>
<blockquote><p>For small data:
insert: RB tree &amp; avl tree has constant number of max rotation but RB tree will be faster because on average RB tree use less rotation.
lookup: AVL tree is faster, because AVL tree has less depth.
delete: RB tree has constant number of max rotation but AVL tree can have O(log N) times of rotation as worst. and on average RB tree also has less number of rotation thus RB tree is faster.
for large data:
insert: AVL tree is faster. because you need to lookup for a particular node before insertion. as you have more data the time difference on looking up the particular node grows proportional to O(log N). but AVL tree &amp; RB tree still only need constant number of rotation at the worst case. Thus the bottle neck will become the time you lookup for that particular node.
lookup: AVL tree is faster. (same as in small data case)
delete: AVL tree is faster on average, but in worst case RB tree is faster. because you also need to lookup for a very deep node to swap before removal (similar to the reason of insertion). on average both trees has constant number of rotation. but RB tree has a constant upper bound for rotation.</p>
</blockquote>

                </article>
                <hr>
            
          
          </div>

          
          
        </div>
        <div class="curtain">
            <div class="avater">
              <a href="/">
                <img src="/static/avater.jpg"/>
              </a>
            </div>
            <h2>Recent Post</h2>
            <ul>
                
                <li>
                    <span>2017-06-05</span> &raquo;
                    <a href="/posts/Redis%E6%80%BB%E7%BB%93">Redis总结</a>
                </li>
                
                <li>
                    <span>2012-12-12</span> &raquo;
                    <a href="/posts/%E6%88%91%E7%9A%84%E4%B9%B1%E5%BC%B9%E2%80%94%E2%80%94%E4%BB%8E%E8%AF%BA%E8%B4%9D%E5%B0%94%E5%A5%96%E8%B0%88%E4%B8%AD%E5%9B%BD%E6%95%99%E8%82%B2">我的乱弹——从诺贝尔奖谈中国教育</a>
                </li>
                
                <li>
                    <span>2012-12-12</span> &raquo;
                    <a href="/posts/%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>
                </li>
                
            </ul>
            <div class="footer">
          &copy; 2016-2019 | <a href="/" title="By George1994">George1994's Blog</a> with
          <a href="/"> Piper</a>.
            </div>
      </div>
    </div>
  </body>
</html>